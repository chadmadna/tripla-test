# Tripla Take-Home Test

Built by Irsyad Nabil for Tripla interview, using template from Eloghene Otiede: https://github.com/geekelo/hello-rails-back-end/


# Quick Start

Prerequisites:
- PostgreSQL
- Rails >= 7.1.2
- Ruby 3.3.1
- Redis

## Database Setup

1. **Create a PostgreSQL User:**

   Use the `createuser` command to create a new PostgreSQL user with the username specified in the `.env.example` file.

   ```bash
   createuser -P -s -e tripla
   ```

   - `-P` prompts for a password (use `tripla` as specified in the `.env.example`).
   - `-s` grants superuser privileges.
   - `-e` echoes the commands that `createuser` generates and sends to the server.

2. **Create a PostgreSQL Database:**

   Use the `createdb` command to create a new database with the name specified in the `.env.example` file.

   ```bash
   createdb -O tripla tripla
   ```

   - `-O` specifies the database owner.

3. **For Testing: Create Database and User**
   ```bash
   createuser -P -s -e tripla_test
   createdb -O tripla_test tripla_test
   ```

## Rails Credentials Setup

If you need to set up Rails credentials, you can use the `RAILS_MASTER_KEY` provided in the `.env.example` file. Replace `replace_with_master_key` with your actual master key.

1. **Edit Rails Credentials:**

   Run the following command to edit the Rails credentials:

   ```bash
   EDITOR="nano" bin/rails credentials:edit
   ```

   - Replace `nano` with your preferred text editor.

2. **Add the Master Key:**

   Ensure that the `config/master.key` file contains the `RAILS_MASTER_KEY` value from the `.env.example` file.

This setup is intended for local development only. Make sure to replace any placeholder values with actual secure values if deploying to a production environment.

### Generating your own master key

To generate your own hex master key, you can use the following command:

```bash
openssl rand -hex 32
```

This command will generate a 32-byte hex string that you can use as your Rails master key. Make sure to update the `RAILS_MASTER_KEY` in your `.env` file with this new key.

## Rails Migrations Setup

1. Run `rails db:migrate`
2. Run `rails db:seed`: It will create 1 admin user and 10 regular users.
   1. Admin user email: `admin@triplatest.com`, password: `admin@tripla!`
   2. Regular user email, where `$` equals number 1 to 10: `user_$@triplatest.com`, password: `user@tripla!`
3. Optionally, run `rails db:seed_large_data` to seed large amounts of data to test with a larger amount of data.

# List of Features

Whilst there are instructions provided to build the REST-ful API, there are some assumptions to be made, and the project will be coded according to said assumptions.

## General assumptions
- Time zone is in UTC (unless specified otherwise in `.env` as `APP_TIMEZONE`).
- Authentication JWT as provided by the Devise gem and its JWT extension.

## Users

- There are user models, with basic authentication and authorization.
	- This assumes auth is needed, and that there will be 2 types of users: admin and regular user roles.
	- The admin and regular users are seeded with their pre-determined roles.
- Admin user can see all users including their clock-in and clock-outs.
	- This assumes admin users have superuser-like privilege.
- All users can log-in and log-out with pre-determined seeded credentials.

### Login

Login and further authentication uses Bearer Token auth.
Store the token (`response.data.user.token`) somewhere (e.g. `localStorage`), and use it in `Authorization: Bearer {token}` header.

```
POST /login
{
    "user": {
        "email": "user_1@triplatest.com",
        "password": "user@tripla!"
    }
}

Response: 200 OK
{
    "status": 200,
    "message": "Logged in successfully.",
    "data": {
        "user": {
            "id": 2,
            "email": "user_1@triplatest.com",
            "roles": [
                "regular"
            ],
            "token": "..."
        }
    }
}
```

### Logout

```
DELETE /logout
Headers:
  Authorization: Bearer ...
```

## Clock-in (and clock-out)

- ### All users can clock in and out using the API endpoints while authenticated:
	- Assumes the timestamp for the clock-in and clock-out are generated by API as the request comes in.
	- Assumes the clock-in/out is for the authenticated user.
	- Assumes a message greets the user in the response.
	- Assumes that once a user is clocked-in, they cannot clock in again before clocking out.
		- Same assumption applies for clocking out.

### Clocking in/out, normal scenario
```
POST /clock-in
Response: 201 Created
{
  "data": {
    "message": "Good morning, Joe! Enjoy your day.",
    "time": "2025-04-07T09:00:00.000Z"
  },
  "statusCode": 201
}
```
```
POST /clock-out
Response: 201 Created
{
  "data": {
    "message": "Good night, Joe. Have a good rest."
    "time": "2025-04-07T21:00:00.000Z"
  },
  "status_code": 201
}
```
### Clocking in/out, with errors
```
# Clocking in without previous clock-out
POST /clock-in
Response: 400 Bad Request
{
  "error": "Cannot clock-in: current user has not clocked-out previously",
  "status_code": 400
}
```
```
# Clocking out without previous clock-in
POST /clock-out
Response: 400 Bad Request
{
  "error": "Cannot clock-out: current user has not clocked-in previously",
  "status_code": 400
}
```
```
# Clocking in/out unauthenticated
POST /clock-out
Response: 401 Unauthorized
{
  "error": "Unauthorized",
  "status_code": 401
}
```

- Technical assumptions:
	- Assumes that clocking in and out does pessimistic locking transaction to prevent dirty reads.
	- Assumes that an attribute `is_clocked_in` exists in the `User` model.
	- Assumes that for a given day where user has clocked-in, it is fine not to clock-out.
		- They can clock-out any time they want after clocking in, doesn't have to be within the same day or within 24 hours.
	- Assumes that a row exists only when user clocked in, and a matching clock-out must also exist.
	- Dates are in ISO8601 format.

## Following/Unfollowing Users
- Users start with zero followers and zero followings.
- User can browse for users to follow.
- Following users without accept/reject follower request.
- User follows are immediate, and the user following can see all the clock-in/out history of the followed user.

### Follow/unfollow, normal scenario
```
POST /users/regularuser1/follow
Response: 200 OK
{
  "status_code": 200
}
```
```
POST /users/regularuser1/unfollow
Response: 200 OK
{
  "status_code": 200
}
```
### Follow/unfollow, with errors
```
# Following after already followed
POST /users/regularuser1/follow
Response: 400 Bad Request
{
  "error": "Cannot follow user: current user already follows user 'regularuser1'",
  "status_code": 400
}
```
```
# Following after already unfollowed
POST /users/regularuser1/unfollow
Response: 400 Bad Request
{
  "error": "Cannot unfollow user: current user is not following user 'regularuser1'",
  "status_code": 400
}
```
```
# Follow/unfollow unauthenticated
POST /users/regularuser1/follow
Response: 401 Unauthorized
{
  "error": "Unauthorized",
  "status_code": 401
}
```

## View Users
- Users can view list of all users.
- Users can filter list of all users based on the following:
	- All users (no status params for admin users)
	- Following (`users/following`)
	- Followers (`users/followers`)
	- Discover (not followed) (`users/`)
- User can browse for users to follow.
- Admin user accounts are not displayed in regular users' discover list.
- Accessing user details endpoint will display user details such as id, and name.
	- If current user is already following the user of the user details endpoint, it will also display a paginated list of the user's clock-in/out records, sorted by created_at descending.

### View paginated users, normal scenario
```
GET /users?page=2&per_page=15
Response: 200 OK
{
  "data": {
    "users": [
	  {
	    "id": 1,
	    "name": "Regular User 1"
	  },
	  ...
	],
    "page": 2,
    "per_page": 15,
    "total": 99
  },
  "status_code": 200
}
```
```
GET /users/followers?page=2&per_page=15
Response: 200 OK
{
  "data": {
    "users": [
	  {
	    "id": 3,
	    "name": "Regular User 3"
	  },
	  ...
	],
    "page": 2,
    "per_page": 15,
    "total": 24
  },
  "status_code": 200
}
```
```
GET /users/following?page=3&per_page=10
Response: 200 OK
{
  "data": {
    "users": [
	  {
	    "id": 9,
	    "name": "Regular User 9"
	  },
	  ...
	],
    "page": 3,
    "per_page": 10,
    "total": 39
  },
  "status_code": 200
}
```

### View paginated users, with errors
```
# View users unauthenticated
GET /users
Response: 401 Unauthorized
{
  "error": "Unauthorized",
  "statusCode": 401
}
```
### View user details, normal scenario
```
GET /users/1
Response: 200 OK
{
  "data": {
    "id": 1,
    "name": "Regular User 1",
    "status": "Awake",
    "records": [
      {
        "clock_in": "2025-04-07T09:00:00.000Z",
        "clock_out": "2025-04-07T21:00:00.000Z",
        "duration": "12:00:00"
      },
      {
        "clock_in": "2025-04-08T09:16:00.000Z",
        "clock_out": null,
        "duration": "02:44:00" // up to current time e.g. querying at 12pm
      },
      ...
    ]
  },
  "statusCode": 200
}
```
### View paginated users, with errors
```
# View users unauthenticated, or not following
GET /users/regularuser1
Response: 401 Unauthorized
{
  "error": "Unauthorized",
  "statusCode": 401
}
```

## View Sleep Records (clock-in/out)
- Views a list of all sleep (clock-in/out) records of the followings of the current user, sorted by duration descending.
	- Sleep record is shown as the time between 1st clock-out to 2nd clock-in, 2nd clock-out to 3rd clock-in, and so on.
	- Assumes current user is also included in the sleep records list.
	- Assumes only complete clockout-clockin pairs are included, meaning clock-in cannot be null.
	- Duration is displayed as humanized format.

### View all sleep records, normal scenario
```
# Current time: 9 April 2025, 09:00:00
GET /sleep_schedules?page=2&per_page=15
Response: 200 OK
{
  "data": [
    {
      "user_id": 1,
      "name": "Regular User 1",
      "clock_out": "2025-04-07T21:00:00.000Z",
      "clock_in": "2025-04-08T09:00:00.000Z",
      "duration": "12 hours"
    },
    {
      "user_id": 2,
      "name": "Regular User 2",
      "clock_out": "2025-04-06T22:34:00.000Z",
      "clock_in": "2025-04-07T09:16:00.000Z",
      "duration": "10 hours and 42 minutes"
    },
    ...
  ],
  "statusCode": 200
}
```
### View all sleep records, with errors
```
# View sleep records unauthenticated
GET /sleep-records
Response: 401 Unauthorized
{
  "error": "Unauthorized",
  "statusCode": 401
}
```
# Overall strategies

Given that:
> "... the system must efficiently handle a growing user base, managing high data volumes and concurrent requests"

We approach different availability and consistency strategies for different features.

- For the user follow/unfollow feature, we prioritize availability by using optimistic locking via the `lock_version` column on `UserFollow` and `User` model.
- For the clock-in/out feature, we prioritize consistency by using pessimistic locking and transactions on both clock-in and clock-out endpoints.

For efforts outside of the application level, we can implement caching, database indexing, and load balancing.
- `@TODO: Implement Redis caching`

# Testing

- Run `rails db:test:prepare`
